<<<<<<< HEAD
import type { Maybe } from '../jsutils/Maybe';
import type { ObjMap } from '../jsutils/ObjMap';
import type { Path } from '../jsutils/Path';
import type { PromiseOrValue } from '../jsutils/PromiseOrValue';
import type {
  EnumTypeDefinitionNode,
  EnumTypeExtensionNode,
  EnumValueDefinitionNode,
  FieldDefinitionNode,
  FieldNode,
  FragmentDefinitionNode,
  InputObjectTypeDefinitionNode,
  InputObjectTypeExtensionNode,
  InputValueDefinitionNode,
  InterfaceTypeDefinitionNode,
  InterfaceTypeExtensionNode,
  ObjectTypeDefinitionNode,
  ObjectTypeExtensionNode,
  OperationDefinitionNode,
  ScalarTypeDefinitionNode,
  ScalarTypeExtensionNode,
  UnionTypeDefinitionNode,
  UnionTypeExtensionNode,
  ValueNode,
} from '../language/ast';
import type { GraphQLSchema } from './schema';
/**
 * These are all of the possible kinds of types.
 */
export declare type GraphQLType =
=======
// FIXME
/* eslint-disable import/no-cycle */

import { Maybe } from '../jsutils/Maybe';

import { PromiseOrValue } from '../jsutils/PromiseOrValue';
import { Path } from '../jsutils/Path';

import {
  ScalarTypeDefinitionNode,
  ObjectTypeDefinitionNode,
  FieldDefinitionNode,
  InputValueDefinitionNode,
  InterfaceTypeDefinitionNode,
  UnionTypeDefinitionNode,
  EnumTypeDefinitionNode,
  EnumValueDefinitionNode,
  InputObjectTypeDefinitionNode,
  ObjectTypeExtensionNode,
  InterfaceTypeExtensionNode,
  OperationDefinitionNode,
  FieldNode,
  FragmentDefinitionNode,
  ValueNode,
  ScalarTypeExtensionNode,
  UnionTypeExtensionNode,
  EnumTypeExtensionNode,
  InputObjectTypeExtensionNode,
} from '../language/ast';

import { GraphQLSchema } from './schema';

/**
 * These are all of the possible kinds of types.
 */
export type GraphQLType =
>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
  | GraphQLScalarType
  | GraphQLObjectType
  | GraphQLInterfaceType
  | GraphQLUnionType
  | GraphQLEnumType
  | GraphQLInputObjectType
<<<<<<< HEAD
  | GraphQLList<GraphQLType>
  | GraphQLNonNull<
      | GraphQLScalarType
      | GraphQLObjectType
      | GraphQLInterfaceType
      | GraphQLUnionType
      | GraphQLEnumType
      | GraphQLInputObjectType
      | GraphQLList<GraphQLType>
    >;
export declare function isType(type: unknown): type is GraphQLType;
export declare function assertType(type: unknown): GraphQLType;
/**
 * There are predicates for each kind of GraphQL type.
 */
export declare function isScalarType(type: unknown): type is GraphQLScalarType;
export declare function assertScalarType(type: unknown): GraphQLScalarType;
export declare function isObjectType(type: unknown): type is GraphQLObjectType;
export declare function assertObjectType(type: unknown): GraphQLObjectType;
export declare function isInterfaceType(
  type: unknown,
): type is GraphQLInterfaceType;
export declare function assertInterfaceType(
  type: unknown,
): GraphQLInterfaceType;
export declare function isUnionType(type: unknown): type is GraphQLUnionType;
export declare function assertUnionType(type: unknown): GraphQLUnionType;
export declare function isEnumType(type: unknown): type is GraphQLEnumType;
export declare function assertEnumType(type: unknown): GraphQLEnumType;
export declare function isInputObjectType(
  type: unknown,
): type is GraphQLInputObjectType;
export declare function assertInputObjectType(
  type: unknown,
): GraphQLInputObjectType;
export declare function isListType(
  type: GraphQLInputType,
): type is GraphQLList<GraphQLInputType>;
export declare function isListType(
  type: GraphQLOutputType,
): type is GraphQLList<GraphQLOutputType>;
export declare function isListType(
  type: unknown,
): type is GraphQLList<GraphQLType>;
export declare function assertListType(type: unknown): GraphQLList<GraphQLType>;
export declare function isNonNullType(
  type: GraphQLInputType,
): type is GraphQLNonNull<GraphQLInputType>;
export declare function isNonNullType(
  type: GraphQLOutputType,
): type is GraphQLNonNull<GraphQLOutputType>;
export declare function isNonNullType(
  type: unknown,
): type is GraphQLNonNull<GraphQLType>;
export declare function assertNonNullType(
  type: unknown,
): GraphQLNonNull<GraphQLType>;
/**
 * These types may be used as input types for arguments and directives.
 */
export declare type GraphQLInputType =
  | GraphQLScalarType
  | GraphQLEnumType
  | GraphQLInputObjectType
  | GraphQLList<GraphQLInputType>
=======
  | GraphQLList<any>
  | GraphQLNonNull<any>;

export function isType(type: any): type is GraphQLType;

export function assertType(type: any): GraphQLType;

export function isScalarType(type: any): type is GraphQLScalarType;

export function assertScalarType(type: any): GraphQLScalarType;

export function isObjectType(type: any): type is GraphQLObjectType;

export function assertObjectType(type: any): GraphQLObjectType;

export function isInterfaceType(type: any): type is GraphQLInterfaceType;

export function assertInterfaceType(type: any): GraphQLInterfaceType;

export function isUnionType(type: any): type is GraphQLUnionType;

export function assertUnionType(type: any): GraphQLUnionType;

export function isEnumType(type: any): type is GraphQLEnumType;

export function assertEnumType(type: any): GraphQLEnumType;

export function isInputObjectType(type: any): type is GraphQLInputObjectType;

export function assertInputObjectType(type: any): GraphQLInputObjectType;

export function isListType(type: any): type is GraphQLList<any>;

export function assertListType(type: any): GraphQLList<any>;

export function isNonNullType(type: any): type is GraphQLNonNull<any>;

export function assertNonNullType(type: any): GraphQLNonNull<any>;

/**
 * These types may be used as input types for arguments and directives.
 */
// TS_SPECIFIC: TS does not allow recursive type definitions, hence the `any`s
export type GraphQLInputType =
  | GraphQLScalarType
  | GraphQLEnumType
  | GraphQLInputObjectType
  | GraphQLList<any>
>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
  | GraphQLNonNull<
      | GraphQLScalarType
      | GraphQLEnumType
      | GraphQLInputObjectType
<<<<<<< HEAD
      | GraphQLList<GraphQLInputType>
    >;
export declare function isInputType(type: unknown): type is GraphQLInputType;
export declare function assertInputType(type: unknown): GraphQLInputType;
/**
 * These types may be used as output types as the result of fields.
 */
export declare type GraphQLOutputType =
=======
      | GraphQLList<any>
    >;

export function isInputType(type: any): type is GraphQLInputType;

export function assertInputType(type: any): GraphQLInputType;

/**
 * These types may be used as output types as the result of fields.
 */
// TS_SPECIFIC: TS does not allow recursive type definitions, hence the `any`s
export type GraphQLOutputType =
>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
  | GraphQLScalarType
  | GraphQLObjectType
  | GraphQLInterfaceType
  | GraphQLUnionType
  | GraphQLEnumType
<<<<<<< HEAD
  | GraphQLList<GraphQLOutputType>
=======
  | GraphQLList<any>
>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
  | GraphQLNonNull<
      | GraphQLScalarType
      | GraphQLObjectType
      | GraphQLInterfaceType
      | GraphQLUnionType
      | GraphQLEnumType
<<<<<<< HEAD
      | GraphQLList<GraphQLOutputType>
    >;
export declare function isOutputType(type: unknown): type is GraphQLOutputType;
export declare function assertOutputType(type: unknown): GraphQLOutputType;
/**
 * These types may describe types which may be leaf values.
 */
export declare type GraphQLLeafType = GraphQLScalarType | GraphQLEnumType;
export declare function isLeafType(type: unknown): type is GraphQLLeafType;
export declare function assertLeafType(type: unknown): GraphQLLeafType;
/**
 * These types may describe the parent context of a selection set.
 */
export declare type GraphQLCompositeType =
  | GraphQLObjectType
  | GraphQLInterfaceType
  | GraphQLUnionType;
export declare function isCompositeType(
  type: unknown,
): type is GraphQLCompositeType;
export declare function assertCompositeType(
  type: unknown,
): GraphQLCompositeType;
/**
 * These types may describe the parent context of a selection set.
 */
export declare type GraphQLAbstractType =
  | GraphQLInterfaceType
  | GraphQLUnionType;
export declare function isAbstractType(
  type: unknown,
): type is GraphQLAbstractType;
export declare function assertAbstractType(type: unknown): GraphQLAbstractType;
/**
 * List Type Wrapper
 *
 * A list is a wrapping type which points to another type.
 * Lists are often created within the context of defining the fields of
 * an object type.
 *
 * Example:
 *
 * ```ts
 * const PersonType = new GraphQLObjectType({
 *   name: 'Person',
 *   fields: () => ({
 *     parents: { type: new GraphQLList(PersonType) },
 *     children: { type: new GraphQLList(PersonType) },
 *   })
 * })
 * ```
 */
export declare class GraphQLList<T extends GraphQLType> {
  readonly ofType: T;
  constructor(ofType: T);
  get [Symbol.toStringTag](): string;
  toString(): string;
  toJSON(): string;
}
/**
 * Non-Null Type Wrapper
 *
 * A non-null is a wrapping type which points to another type.
 * Non-null types enforce that their values are never null and can ensure
=======
      | GraphQLList<any>
    >;

export function isOutputType(type: any): type is GraphQLOutputType;

export function assertOutputType(type: any): GraphQLOutputType;

/**
 * These types may describe types which may be leaf values.
 */
export type GraphQLLeafType = GraphQLScalarType | GraphQLEnumType;

export function isLeafType(type: any): type is GraphQLLeafType;

export function assertLeafType(type: any): GraphQLLeafType;

/**
 * These types may describe the parent context of a selection set.
 */
export type GraphQLCompositeType =
  | GraphQLObjectType
  | GraphQLInterfaceType
  | GraphQLUnionType;

export function isCompositeType(type: any): type is GraphQLCompositeType;

export function assertCompositeType(type: any): GraphQLCompositeType;

/**
 * These types may describe the parent context of a selection set.
 */
export type GraphQLAbstractType = GraphQLInterfaceType | GraphQLUnionType;

export function isAbstractType(type: any): type is GraphQLAbstractType;

export function assertAbstractType(type: any): GraphQLAbstractType;

/**
 * List Modifier
 *
 * A list is a kind of type marker, a wrapping type which points to another
 * type. Lists are often created within the context of defining the fields
 * of an object type.
 *
 * Example:
 *
 *     const PersonType = new GraphQLObjectType({
 *       name: 'Person',
 *       fields: () => ({
 *         parents: { type: new GraphQLList(Person) },
 *         children: { type: new GraphQLList(Person) },
 *       })
 *     })
 *
 */
interface GraphQLList<T extends GraphQLType> {
  readonly ofType: T;
  toString: () => string;
  toJSON: () => string;
  inspect: () => string;
}

interface _GraphQLList<T extends GraphQLType> {
  (type: T): GraphQLList<T>;
  new (type: T): GraphQLList<T>;
}

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GraphQLList: _GraphQLList<GraphQLType>;

/**
 * Non-Null Modifier
 *
 * A non-null is a kind of type marker, a wrapping type which points to another
 * type. Non-null types enforce that their values are never null and can ensure
>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
 * an error is raised if this ever occurs during a request. It is useful for
 * fields which you can make a strong guarantee on non-nullability, for example
 * usually the id field of a database row will never be null.
 *
 * Example:
 *
<<<<<<< HEAD
 * ```ts
 * const RowType = new GraphQLObjectType({
 *   name: 'Row',
 *   fields: () => ({
 *     id: { type: new GraphQLNonNull(GraphQLString) },
 *   })
 * })
 * ```
 * Note: the enforcement of non-nullability occurs within the executor.
 */
export declare class GraphQLNonNull<T extends GraphQLNullableType> {
  readonly ofType: T;
  constructor(ofType: T);
  get [Symbol.toStringTag](): string;
  toString(): string;
  toJSON(): string;
}
/**
 * These types wrap and modify other types
 */
export declare type GraphQLWrappingType =
  | GraphQLList<GraphQLType>
  | GraphQLNonNull<GraphQLType>;
export declare function isWrappingType(
  type: unknown,
): type is GraphQLWrappingType;
export declare function assertWrappingType(type: unknown): GraphQLWrappingType;
/**
 * These types can all accept null as a value.
 */
export declare type GraphQLNullableType =
=======
 *     const RowType = new GraphQLObjectType({
 *       name: 'Row',
 *       fields: () => ({
 *         id: { type: new GraphQLNonNull(GraphQLString) },
 *       })
 *     })
 *
 * Note: the enforcement of non-nullability occurs within the executor.
 */
interface GraphQLNonNull<T extends GraphQLNullableType> {
  readonly ofType: T;
  toString: () => string;
  toJSON: () => string;
  inspect: () => string;
}

interface _GraphQLNonNull<T extends GraphQLNullableType> {
  (type: T): GraphQLNonNull<T>;
  new (type: T): GraphQLNonNull<T>;
}

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GraphQLNonNull: _GraphQLNonNull<GraphQLNullableType>;

export type GraphQLWrappingType = GraphQLList<any> | GraphQLNonNull<any>;

export function isWrappingType(type: any): type is GraphQLWrappingType;

export function assertWrappingType(type: any): GraphQLWrappingType;

/**
 * These types can all accept null as a value.
 */
export type GraphQLNullableType =
>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
  | GraphQLScalarType
  | GraphQLObjectType
  | GraphQLInterfaceType
  | GraphQLUnionType
  | GraphQLEnumType
  | GraphQLInputObjectType
<<<<<<< HEAD
  | GraphQLList<GraphQLType>;
export declare function isNullableType(
  type: unknown,
): type is GraphQLNullableType;
export declare function assertNullableType(type: unknown): GraphQLNullableType;
export declare function getNullableType(type: undefined | null): void;
export declare function getNullableType<T extends GraphQLNullableType>(
  type: T | GraphQLNonNull<T>,
): T;
export declare function getNullableType(
  type: Maybe<GraphQLType>,
): GraphQLNullableType | undefined;
/**
 * These named types do not include modifiers like List or NonNull.
 */
export declare type GraphQLNamedType =
  | GraphQLNamedInputType
  | GraphQLNamedOutputType;
export declare type GraphQLNamedInputType =
  | GraphQLScalarType
  | GraphQLEnumType
  | GraphQLInputObjectType;
export declare type GraphQLNamedOutputType =
=======
  | GraphQLList<any>;

export function isNullableType(type: any): type is GraphQLNullableType;

export function assertNullableType(type: any): GraphQLNullableType;

export function getNullableType(type: undefined): undefined;
export function getNullableType<T extends GraphQLNullableType>(type: T): T;
export function getNullableType<T extends GraphQLNullableType>(
  // FIXME Disabled because of https://github.com/yaacovCR/graphql-tools-fork/issues/40#issuecomment-586671219
  // eslint-disable-next-line @typescript-eslint/unified-signatures
  type: GraphQLNonNull<T>,
): T;

/**
 * These named types do not include modifiers like List or NonNull.
 */
export type GraphQLNamedType = GraphQLNamedInputType | GraphQLNamedOutputType;

export type GraphQLNamedInputType =
  | GraphQLScalarType
  | GraphQLEnumType
  | GraphQLInputObjectType;

export type GraphQLNamedOutputType =
>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
  | GraphQLScalarType
  | GraphQLObjectType
  | GraphQLInterfaceType
  | GraphQLUnionType
  | GraphQLEnumType;
<<<<<<< HEAD
export declare function isNamedType(type: unknown): type is GraphQLNamedType;
export declare function assertNamedType(type: unknown): GraphQLNamedType;
export declare function getNamedType(type: undefined | null): void;
export declare function getNamedType(
  type: GraphQLInputType,
): GraphQLNamedInputType;
export declare function getNamedType(
  type: GraphQLOutputType,
): GraphQLNamedOutputType;
export declare function getNamedType(type: GraphQLType): GraphQLNamedType;
export declare function getNamedType(
  type: Maybe<GraphQLType>,
): GraphQLNamedType | undefined;
=======

export function isNamedType(type: any): type is GraphQLNamedType;

export function assertNamedType(type: any): GraphQLNamedType;

export function getNamedType(type: undefined): undefined;
export function getNamedType(type: GraphQLInputType): GraphQLNamedInputType;
export function getNamedType(type: GraphQLOutputType): GraphQLNamedOutputType;
export function getNamedType(type: GraphQLType): GraphQLNamedType;

>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
/**
 * Used while defining GraphQL types to allow for circular references in
 * otherwise immutable type definitions.
 */
<<<<<<< HEAD
export declare type ThunkReadonlyArray<T> =
  | (() => ReadonlyArray<T>)
  | ReadonlyArray<T>;
export declare type ThunkObjMap<T> = (() => ObjMap<T>) | ObjMap<T>;
export declare function resolveReadonlyArrayThunk<T>(
  thunk: ThunkReadonlyArray<T>,
): ReadonlyArray<T>;
export declare function resolveObjMapThunk<T>(thunk: ThunkObjMap<T>): ObjMap<T>;
=======
export type Thunk<T> = (() => T) | T;

>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
/**
 * Custom extensions
 *
 * @remarks
 * Use a unique identifier name for your extension, for example the name of
 * your library or project. Do not use a shortened identifier as this increases
 * the risk of conflicts. We recommend you add at most one extension field,
 * an object which can contain all the values you need.
 */
export interface GraphQLScalarTypeExtensions {
<<<<<<< HEAD
  [attributeName: string]: unknown;
}
=======
  [attributeName: string]: any;
}

>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
/**
 * Scalar Type Definition
 *
 * The leaf values of any request and input values to arguments are
 * Scalars (or Enums) and are defined with a name and a series of functions
 * used to parse input from ast or variables and to ensure validity.
 *
<<<<<<< HEAD
 * If a type's serialize function does not return a value (i.e. it returns
 * `undefined`) then an error will be raised and a `null` value will be returned
 * in the response. If the serialize function returns `null`, then no error will
 * be included in the response.
 *
 * Example:
 *
 * ```ts
 * const OddType = new GraphQLScalarType({
 *   name: 'Odd',
 *   serialize(value) {
 *     if (value % 2 === 1) {
 *       return value;
 *     }
 *   }
 * });
 * ```
 */
export declare class GraphQLScalarType<
  TInternal = unknown,
  TExternal = TInternal,
> {
  name: string;
  description: Maybe<string>;
  specifiedByURL: Maybe<string>;
  serialize: GraphQLScalarSerializer<TExternal>;
  parseValue: GraphQLScalarValueParser<TInternal>;
  parseLiteral: GraphQLScalarLiteralParser<TInternal>;
  extensions: Readonly<GraphQLScalarTypeExtensions>;
  astNode: Maybe<ScalarTypeDefinitionNode>;
  extensionASTNodes: ReadonlyArray<ScalarTypeExtensionNode>;
  constructor(config: Readonly<GraphQLScalarTypeConfig<TInternal, TExternal>>);
  get [Symbol.toStringTag](): string;
  toConfig(): GraphQLScalarTypeNormalizedConfig<TInternal, TExternal>;
  toString(): string;
  toJSON(): string;
}
export declare type GraphQLScalarSerializer<TExternal> = (
  outputValue: unknown,
) => TExternal;
export declare type GraphQLScalarValueParser<TInternal> = (
  inputValue: unknown,
) => TInternal;
export declare type GraphQLScalarLiteralParser<TInternal> = (
  valueNode: ValueNode,
  variables?: Maybe<ObjMap<unknown>>,
) => TInternal;
export interface GraphQLScalarTypeConfig<TInternal, TExternal> {
  name: string;
  description?: Maybe<string>;
  specifiedByURL?: Maybe<string>;
  /** Serializes an internal value to include in a response. */
  serialize?: GraphQLScalarSerializer<TExternal>;
  /** Parses an externally provided value to use as an input. */
  parseValue?: GraphQLScalarValueParser<TInternal>;
  /** Parses an externally provided literal value to use as an input. */
=======
 * Example:
 *
 *     const OddType = new GraphQLScalarType({
 *       name: 'Odd',
 *       serialize(value) {
 *         return value % 2 === 1 ? value : null;
 *       }
 *     });
 *
 */
export class GraphQLScalarType {
  name: string;
  description: Maybe<string>;
  specifiedByUrl: Maybe<string>;
  serialize: GraphQLScalarSerializer<any>;
  parseValue: GraphQLScalarValueParser<any>;
  parseLiteral: GraphQLScalarLiteralParser<any>;
  extensions: Maybe<Readonly<GraphQLScalarTypeExtensions>>;
  astNode: Maybe<ScalarTypeDefinitionNode>;
  extensionASTNodes: Maybe<ReadonlyArray<ScalarTypeExtensionNode>>;

  constructor(config: Readonly<GraphQLScalarTypeConfig<any, any>>);

  toConfig(): GraphQLScalarTypeConfig<any, any> & {
    specifiedByUrl: Maybe<string>;
    serialize: GraphQLScalarSerializer<any>;
    parseValue: GraphQLScalarValueParser<any>;
    parseLiteral: GraphQLScalarLiteralParser<any>;
    extensions: Maybe<Readonly<GraphQLScalarTypeExtensions>>;
    extensionASTNodes: ReadonlyArray<ScalarTypeExtensionNode>;
  };

  toString(): string;
  toJSON(): string;
  inspect(): string;
}

export type GraphQLScalarSerializer<TExternal> = (
  value: any,
) => Maybe<TExternal>;
export type GraphQLScalarValueParser<TInternal> = (
  value: any,
) => Maybe<TInternal>;
export type GraphQLScalarLiteralParser<TInternal> = (
  valueNode: ValueNode,
  variables: Maybe<{ [key: string]: any }>,
) => Maybe<TInternal>;

export interface GraphQLScalarTypeConfig<TInternal, TExternal> {
  name: string;
  description?: Maybe<string>;
  specifiedByUrl?: Maybe<string>;
  // Serializes an internal value to include in a response.
  serialize?: GraphQLScalarSerializer<TExternal>;
  // Parses an externally provided value to use as an input.
  parseValue?: GraphQLScalarValueParser<TInternal>;
  // Parses an externally provided literal value to use as an input.
>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
  parseLiteral?: GraphQLScalarLiteralParser<TInternal>;
  extensions?: Maybe<Readonly<GraphQLScalarTypeExtensions>>;
  astNode?: Maybe<ScalarTypeDefinitionNode>;
  extensionASTNodes?: Maybe<ReadonlyArray<ScalarTypeExtensionNode>>;
}
<<<<<<< HEAD
interface GraphQLScalarTypeNormalizedConfig<TInternal, TExternal>
  extends GraphQLScalarTypeConfig<TInternal, TExternal> {
  serialize: GraphQLScalarSerializer<TExternal>;
  parseValue: GraphQLScalarValueParser<TInternal>;
  parseLiteral: GraphQLScalarLiteralParser<TInternal>;
  extensions: Readonly<GraphQLScalarTypeExtensions>;
  extensionASTNodes: ReadonlyArray<ScalarTypeExtensionNode>;
}
=======

>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
/**
 * Custom extensions
 *
 * @remarks
 * Use a unique identifier name for your extension, for example the name of
 * your library or project. Do not use a shortened identifier as this increases
 * the risk of conflicts. We recommend you add at most one extension field,
 * an object which can contain all the values you need.
 *
 * We've provided these template arguments because this is an open type and
 * you may find them useful.
 */
export interface GraphQLObjectTypeExtensions<_TSource = any, _TContext = any> {
<<<<<<< HEAD
  [attributeName: string]: unknown;
}
=======
  [attributeName: string]: any;
}

>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
/**
 * Object Type Definition
 *
 * Almost all of the GraphQL types you define will be object types. Object types
 * have a name, but most importantly describe their fields.
 *
 * Example:
 *
<<<<<<< HEAD
 * ```ts
 * const AddressType = new GraphQLObjectType({
 *   name: 'Address',
 *   fields: {
 *     street: { type: GraphQLString },
 *     number: { type: GraphQLInt },
 *     formatted: {
 *       type: GraphQLString,
 *       resolve(obj) {
 *         return obj.number + ' ' + obj.street
 *       }
 *     }
 *   }
 * });
 * ```
=======
 *     const AddressType = new GraphQLObjectType({
 *       name: 'Address',
 *       fields: {
 *         street: { type: GraphQLString },
 *         number: { type: GraphQLInt },
 *         formatted: {
 *           type: GraphQLString,
 *           resolve(obj) {
 *             return obj.number + ' ' + obj.street
 *           }
 *         }
 *       }
 *     });
>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
 *
 * When two types need to refer to each other, or a type needs to refer to
 * itself in a field, you can use a function expression (aka a closure or a
 * thunk) to supply the fields lazily.
 *
 * Example:
 *
<<<<<<< HEAD
 * ```ts
 * const PersonType = new GraphQLObjectType({
 *   name: 'Person',
 *   fields: () => ({
 *     name: { type: GraphQLString },
 *     bestFriend: { type: PersonType },
 *   })
 * });
 * ```
 */
export declare class GraphQLObjectType<TSource = any, TContext = any> {
  name: string;
  description: Maybe<string>;
  isTypeOf: Maybe<GraphQLIsTypeOfFn<TSource, TContext>>;
  extensions: Readonly<GraphQLObjectTypeExtensions<TSource, TContext>>;
  astNode: Maybe<ObjectTypeDefinitionNode>;
  extensionASTNodes: ReadonlyArray<ObjectTypeExtensionNode>;
  private _fields;
  private _interfaces;
  constructor(config: Readonly<GraphQLObjectTypeConfig<TSource, TContext>>);
  get [Symbol.toStringTag](): string;
  getFields(): GraphQLFieldMap<TSource, TContext>;
  getInterfaces(): ReadonlyArray<GraphQLInterfaceType>;
  toConfig(): GraphQLObjectTypeNormalizedConfig<TSource, TContext>;
  toString(): string;
  toJSON(): string;
}
export declare function defineArguments(
  config: GraphQLFieldConfigArgumentMap,
): ReadonlyArray<GraphQLArgument>;
/**
 * @internal
 */
export declare function argsToArgsConfig(
  args: ReadonlyArray<GraphQLArgument>,
): GraphQLFieldConfigArgumentMap;
export interface GraphQLObjectTypeConfig<TSource, TContext> {
  name: string;
  description?: Maybe<string>;
  interfaces?: ThunkReadonlyArray<GraphQLInterfaceType>;
  fields: ThunkObjMap<GraphQLFieldConfig<TSource, TContext>>;
=======
 *     const PersonType = new GraphQLObjectType({
 *       name: 'Person',
 *       fields: () => ({
 *         name: { type: GraphQLString },
 *         bestFriend: { type: PersonType },
 *       })
 *     });
 *
 */
export class GraphQLObjectType<TSource = any, TContext = any> {
  name: string;
  description: Maybe<string>;
  isTypeOf: Maybe<GraphQLIsTypeOfFn<TSource, TContext>>;
  extensions: Maybe<Readonly<GraphQLObjectTypeExtensions<TSource, TContext>>>;
  astNode: Maybe<ObjectTypeDefinitionNode>;
  extensionASTNodes: Maybe<ReadonlyArray<ObjectTypeExtensionNode>>;

  constructor(config: Readonly<GraphQLObjectTypeConfig<TSource, TContext>>);

  getFields(): GraphQLFieldMap<any, TContext>;
  getInterfaces(): Array<GraphQLInterfaceType>;

  toConfig(): GraphQLObjectTypeConfig<any, any> & {
    interfaces: Array<GraphQLInterfaceType>;
    fields: GraphQLFieldConfigMap<any, any>;
    extensions: Maybe<Readonly<GraphQLObjectTypeExtensions<TSource, TContext>>>;
    extensionASTNodes: ReadonlyArray<ObjectTypeExtensionNode>;
  };

  toString(): string;
  toJSON(): string;
  inspect(): string;
}

export function argsToArgsConfig(
  args: ReadonlyArray<GraphQLArgument>,
): GraphQLFieldConfigArgumentMap;

export interface GraphQLObjectTypeConfig<TSource, TContext> {
  name: string;
  description?: Maybe<string>;
  interfaces?: Thunk<Maybe<Array<GraphQLInterfaceType>>>;
  fields: Thunk<GraphQLFieldConfigMap<TSource, TContext>>;
>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
  isTypeOf?: Maybe<GraphQLIsTypeOfFn<TSource, TContext>>;
  extensions?: Maybe<Readonly<GraphQLObjectTypeExtensions<TSource, TContext>>>;
  astNode?: Maybe<ObjectTypeDefinitionNode>;
  extensionASTNodes?: Maybe<ReadonlyArray<ObjectTypeExtensionNode>>;
}
<<<<<<< HEAD
interface GraphQLObjectTypeNormalizedConfig<TSource, TContext>
  extends GraphQLObjectTypeConfig<any, any> {
  interfaces: ReadonlyArray<GraphQLInterfaceType>;
  fields: GraphQLFieldConfigMap<any, any>;
  extensions: Readonly<GraphQLObjectTypeExtensions<TSource, TContext>>;
  extensionASTNodes: ReadonlyArray<ObjectTypeExtensionNode>;
}
export declare type GraphQLTypeResolver<TSource, TContext> = (
=======

export type GraphQLTypeResolver<TSource, TContext> = (
>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
  value: TSource,
  context: TContext,
  info: GraphQLResolveInfo,
  abstractType: GraphQLAbstractType,
<<<<<<< HEAD
) => PromiseOrValue<string | undefined>;
export declare type GraphQLIsTypeOfFn<TSource, TContext> = (
=======
) => PromiseOrValue<Maybe<GraphQLObjectType<TSource, TContext> | string>>;

export type GraphQLIsTypeOfFn<TSource, TContext> = (
>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
  source: TSource,
  context: TContext,
  info: GraphQLResolveInfo,
) => PromiseOrValue<boolean>;
<<<<<<< HEAD
export declare type GraphQLFieldResolver<
  TSource,
  TContext,
  TArgs = any,
  TResult = unknown,
=======

export type GraphQLFieldResolver<
  TSource,
  TContext,
  TArgs = { [argName: string]: any }
>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
> = (
  source: TSource,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo,
<<<<<<< HEAD
) => TResult;
=======
) => any;

>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
export interface GraphQLResolveInfo {
  readonly fieldName: string;
  readonly fieldNodes: ReadonlyArray<FieldNode>;
  readonly returnType: GraphQLOutputType;
  readonly parentType: GraphQLObjectType;
  readonly path: Path;
  readonly schema: GraphQLSchema;
<<<<<<< HEAD
  readonly fragments: ObjMap<FragmentDefinitionNode>;
  readonly rootValue: unknown;
  readonly operation: OperationDefinitionNode;
  readonly variableValues: {
    [variable: string]: unknown;
  };
}
=======
  readonly fragments: { [key: string]: FragmentDefinitionNode };
  readonly rootValue: any;
  readonly operation: OperationDefinitionNode;
  readonly variableValues: { [variableName: string]: any };
}

>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
/**
 * Custom extensions
 *
 * @remarks
 * Use a unique identifier name for your extension, for example the name of
 * your library or project. Do not use a shortened identifier as this increases
 * the risk of conflicts. We recommend you add at most one extension field,
 * an object which can contain all the values you need.
 *
 * We've provided these template arguments because this is an open type and
 * you may find them useful.
 */
<<<<<<< HEAD
export interface GraphQLFieldExtensions<_TSource, _TContext, _TArgs = any> {
  [attributeName: string]: unknown;
}
export interface GraphQLFieldConfig<TSource, TContext, TArgs = any> {
=======
export interface GraphQLFieldExtensions<
  _TSource,
  _TContext,
  _TArgs = { [argName: string]: any }
> {
  [attributeName: string]: any;
}

export interface GraphQLFieldConfig<
  TSource,
  TContext,
  TArgs = { [argName: string]: any }
> {
>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
  description?: Maybe<string>;
  type: GraphQLOutputType;
  args?: GraphQLFieldConfigArgumentMap;
  resolve?: GraphQLFieldResolver<TSource, TContext, TArgs>;
  subscribe?: GraphQLFieldResolver<TSource, TContext, TArgs>;
  deprecationReason?: Maybe<string>;
  extensions?: Maybe<
    Readonly<GraphQLFieldExtensions<TSource, TContext, TArgs>>
  >;
  astNode?: Maybe<FieldDefinitionNode>;
}
<<<<<<< HEAD
export declare type GraphQLFieldConfigArgumentMap =
  ObjMap<GraphQLArgumentConfig>;
=======

export interface GraphQLFieldConfigArgumentMap {
  [key: string]: GraphQLArgumentConfig;
}

>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
/**
 * Custom extensions
 *
 * @remarks
 * Use a unique identifier name for your extension, for example the name of
 * your library or project. Do not use a shortened identifier as this increases
 * the risk of conflicts. We recommend you add at most one extension field,
 * an object which can contain all the values you need.
 */
export interface GraphQLArgumentExtensions {
<<<<<<< HEAD
  [attributeName: string]: unknown;
}
export interface GraphQLArgumentConfig {
  description?: Maybe<string>;
  type: GraphQLInputType;
  defaultValue?: unknown;
=======
  [attributeName: string]: any;
}

export interface GraphQLArgumentConfig {
  description?: Maybe<string>;
  type: GraphQLInputType;
  defaultValue?: any;
>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
  deprecationReason?: Maybe<string>;
  extensions?: Maybe<Readonly<GraphQLArgumentExtensions>>;
  astNode?: Maybe<InputValueDefinitionNode>;
}
<<<<<<< HEAD
export declare type GraphQLFieldConfigMap<TSource, TContext> = ObjMap<
  GraphQLFieldConfig<TSource, TContext>
>;
export interface GraphQLField<TSource, TContext, TArgs = any> {
  name: string;
  description: Maybe<string>;
  type: GraphQLOutputType;
  args: ReadonlyArray<GraphQLArgument>;
  resolve?: GraphQLFieldResolver<TSource, TContext, TArgs>;
  subscribe?: GraphQLFieldResolver<TSource, TContext, TArgs>;
  deprecationReason: Maybe<string>;
  extensions: Readonly<GraphQLFieldExtensions<TSource, TContext, TArgs>>;
  astNode: Maybe<FieldDefinitionNode>;
}
=======

export interface GraphQLFieldConfigMap<TSource, TContext> {
  [key: string]: GraphQLFieldConfig<TSource, TContext>;
}

export interface GraphQLField<
  TSource,
  TContext,
  TArgs = { [key: string]: any }
> {
  name: string;
  description: Maybe<string>;
  type: GraphQLOutputType;
  args: Array<GraphQLArgument>;
  resolve?: GraphQLFieldResolver<TSource, TContext, TArgs>;
  subscribe?: GraphQLFieldResolver<TSource, TContext, TArgs>;
  deprecationReason: Maybe<string>;
  extensions: Maybe<Readonly<GraphQLFieldExtensions<TSource, TContext, TArgs>>>;
  astNode?: Maybe<FieldDefinitionNode>;

  // @deprecated and will be removed in v16
  isDeprecated: boolean;
}

>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
export interface GraphQLArgument {
  name: string;
  description: Maybe<string>;
  type: GraphQLInputType;
<<<<<<< HEAD
  defaultValue: unknown;
  deprecationReason: Maybe<string>;
  extensions: Readonly<GraphQLArgumentExtensions>;
  astNode: Maybe<InputValueDefinitionNode>;
}
export declare function isRequiredArgument(arg: GraphQLArgument): boolean;
export declare type GraphQLFieldMap<TSource, TContext> = ObjMap<
  GraphQLField<TSource, TContext>
>;
=======
  defaultValue: any;
  deprecationReason: Maybe<string>;
  extensions: Maybe<Readonly<GraphQLArgumentExtensions>>;
  astNode: Maybe<InputValueDefinitionNode>;
}

export function isRequiredArgument(arg: GraphQLArgument): boolean;

export interface GraphQLFieldMap<TSource, TContext> {
  [key: string]: GraphQLField<TSource, TContext>;
}

>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
/**
 * Custom extensions
 *
 * @remarks
 * Use a unique identifier name for your extension, for example the name of
 * your library or project. Do not use a shortened identifier as this increases
 * the risk of conflicts. We recommend you add at most one extension field,
 * an object which can contain all the values you need.
 */
export interface GraphQLInterfaceTypeExtensions {
<<<<<<< HEAD
  [attributeName: string]: unknown;
}
=======
  [attributeName: string]: any;
}

>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
/**
 * Interface Type Definition
 *
 * When a field can return one of a heterogeneous set of types, a Interface type
 * is used to describe what types are possible, what fields are in common across
 * all types, as well as a function to determine which type is actually used
 * when the field is resolved.
 *
 * Example:
 *
<<<<<<< HEAD
 * ```ts
 * const EntityType = new GraphQLInterfaceType({
 *   name: 'Entity',
 *   fields: {
 *     name: { type: GraphQLString }
 *   }
 * });
 * ```
 */
export declare class GraphQLInterfaceType {
  name: string;
  description: Maybe<string>;
  resolveType: Maybe<GraphQLTypeResolver<any, any>>;
  extensions: Readonly<GraphQLInterfaceTypeExtensions>;
  astNode: Maybe<InterfaceTypeDefinitionNode>;
  extensionASTNodes: ReadonlyArray<InterfaceTypeExtensionNode>;
  private _fields;
  private _interfaces;
  constructor(config: Readonly<GraphQLInterfaceTypeConfig<any, any>>);
  get [Symbol.toStringTag](): string;
  getFields(): GraphQLFieldMap<any, any>;
  getInterfaces(): ReadonlyArray<GraphQLInterfaceType>;
  toConfig(): GraphQLInterfaceTypeNormalizedConfig;
  toString(): string;
  toJSON(): string;
}
export interface GraphQLInterfaceTypeConfig<TSource, TContext> {
  name: string;
  description?: Maybe<string>;
  interfaces?: ThunkReadonlyArray<GraphQLInterfaceType>;
  fields: ThunkObjMap<GraphQLFieldConfig<TSource, TContext>>;
=======
 *     const EntityType = new GraphQLInterfaceType({
 *       name: 'Entity',
 *       fields: {
 *         name: { type: GraphQLString }
 *       }
 *     });
 *
 */
export class GraphQLInterfaceType {
  name: string;
  description: Maybe<string>;
  resolveType: Maybe<GraphQLTypeResolver<any, any>>;
  extensions: Maybe<Readonly<GraphQLInterfaceTypeExtensions>>;
  astNode?: Maybe<InterfaceTypeDefinitionNode>;
  extensionASTNodes: Maybe<ReadonlyArray<InterfaceTypeExtensionNode>>;

  constructor(config: Readonly<GraphQLInterfaceTypeConfig<any, any>>);
  getFields(): GraphQLFieldMap<any, any>;
  getInterfaces(): Array<GraphQLInterfaceType>;

  toConfig(): GraphQLInterfaceTypeConfig<any, any> & {
    interfaces: Array<GraphQLInterfaceType>;
    fields: GraphQLFieldConfigMap<any, any>;
    extensions: Maybe<Readonly<GraphQLInterfaceTypeExtensions>>;
    extensionASTNodes: ReadonlyArray<InterfaceTypeExtensionNode>;
  };

  toString(): string;
  toJSON(): string;
  inspect(): string;
}

export interface GraphQLInterfaceTypeConfig<TSource, TContext> {
  name: string;
  description?: Maybe<string>;
  interfaces?: Thunk<Maybe<Array<GraphQLInterfaceType>>>;
  fields: Thunk<GraphQLFieldConfigMap<TSource, TContext>>;
>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
  /**
   * Optionally provide a custom type resolver function. If one is not provided,
   * the default implementation will call `isTypeOf` on each implementing
   * Object type.
   */
  resolveType?: Maybe<GraphQLTypeResolver<TSource, TContext>>;
  extensions?: Maybe<Readonly<GraphQLInterfaceTypeExtensions>>;
  astNode?: Maybe<InterfaceTypeDefinitionNode>;
  extensionASTNodes?: Maybe<ReadonlyArray<InterfaceTypeExtensionNode>>;
}
<<<<<<< HEAD
export interface GraphQLInterfaceTypeNormalizedConfig
  extends GraphQLInterfaceTypeConfig<any, any> {
  interfaces: ReadonlyArray<GraphQLInterfaceType>;
  fields: GraphQLFieldConfigMap<any, any>;
  extensions: Readonly<GraphQLInterfaceTypeExtensions>;
  extensionASTNodes: ReadonlyArray<InterfaceTypeExtensionNode>;
}
=======

>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
/**
 * Custom extensions
 *
 * @remarks
 * Use a unique identifier name for your extension, for example the name of
 * your library or project. Do not use a shortened identifier as this increases
 * the risk of conflicts. We recommend you add at most one extension field,
 * an object which can contain all the values you need.
 */
export interface GraphQLUnionTypeExtensions {
<<<<<<< HEAD
  [attributeName: string]: unknown;
}
=======
  [attributeName: string]: any;
}

>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
/**
 * Union Type Definition
 *
 * When a field can return one of a heterogeneous set of types, a Union type
 * is used to describe what types are possible as well as providing a function
 * to determine which type is actually used when the field is resolved.
 *
 * Example:
 *
<<<<<<< HEAD
 * ```ts
 * const PetType = new GraphQLUnionType({
 *   name: 'Pet',
 *   types: [ DogType, CatType ],
 *   resolveType(value) {
 *     if (value instanceof Dog) {
 *       return DogType;
 *     }
 *     if (value instanceof Cat) {
 *       return CatType;
 *     }
 *   }
 * });
 * ```
 */
export declare class GraphQLUnionType {
  name: string;
  description: Maybe<string>;
  resolveType: Maybe<GraphQLTypeResolver<any, any>>;
  extensions: Readonly<GraphQLUnionTypeExtensions>;
  astNode: Maybe<UnionTypeDefinitionNode>;
  extensionASTNodes: ReadonlyArray<UnionTypeExtensionNode>;
  private _types;
  constructor(config: Readonly<GraphQLUnionTypeConfig<any, any>>);
  get [Symbol.toStringTag](): string;
  getTypes(): ReadonlyArray<GraphQLObjectType>;
  toConfig(): GraphQLUnionTypeNormalizedConfig;
  toString(): string;
  toJSON(): string;
}
export interface GraphQLUnionTypeConfig<TSource, TContext> {
  name: string;
  description?: Maybe<string>;
  types: ThunkReadonlyArray<GraphQLObjectType>;
=======
 *     const PetType = new GraphQLUnionType({
 *       name: 'Pet',
 *       types: [ DogType, CatType ],
 *       resolveType(value) {
 *         if (value instanceof Dog) {
 *           return DogType;
 *         }
 *         if (value instanceof Cat) {
 *           return CatType;
 *         }
 *       }
 *     });
 *
 */
export class GraphQLUnionType {
  name: string;
  description: Maybe<string>;
  resolveType: Maybe<GraphQLTypeResolver<any, any>>;
  extensions: Maybe<Readonly<GraphQLUnionTypeExtensions>>;
  astNode: Maybe<UnionTypeDefinitionNode>;
  extensionASTNodes: Maybe<ReadonlyArray<UnionTypeExtensionNode>>;

  constructor(config: Readonly<GraphQLUnionTypeConfig<any, any>>);
  getTypes(): Array<GraphQLObjectType>;

  toConfig(): GraphQLUnionTypeConfig<any, any> & {
    types: Array<GraphQLObjectType>;
    extensions: Maybe<Readonly<GraphQLUnionTypeExtensions>>;
    extensionASTNodes: ReadonlyArray<UnionTypeExtensionNode>;
  };

  toString(): string;
  toJSON(): string;
  inspect(): string;
}

export interface GraphQLUnionTypeConfig<TSource, TContext> {
  name: string;
  description?: Maybe<string>;
  types: Thunk<Array<GraphQLObjectType>>;
>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
  /**
   * Optionally provide a custom type resolver function. If one is not provided,
   * the default implementation will call `isTypeOf` on each implementing
   * Object type.
   */
  resolveType?: Maybe<GraphQLTypeResolver<TSource, TContext>>;
  extensions?: Maybe<Readonly<GraphQLUnionTypeExtensions>>;
  astNode?: Maybe<UnionTypeDefinitionNode>;
  extensionASTNodes?: Maybe<ReadonlyArray<UnionTypeExtensionNode>>;
}
<<<<<<< HEAD
interface GraphQLUnionTypeNormalizedConfig
  extends GraphQLUnionTypeConfig<any, any> {
  types: ReadonlyArray<GraphQLObjectType>;
  extensions: Readonly<GraphQLUnionTypeExtensions>;
  extensionASTNodes: ReadonlyArray<UnionTypeExtensionNode>;
}
=======

>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
/**
 * Custom extensions
 *
 * @remarks
 * Use a unique identifier name for your extension, for example the name of
 * your library or project. Do not use a shortened identifier as this increases
 * the risk of conflicts. We recommend you add at most one extension field,
 * an object which can contain all the values you need.
 */
export interface GraphQLEnumTypeExtensions {
<<<<<<< HEAD
  [attributeName: string]: unknown;
}
=======
  [attributeName: string]: any;
}

>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
/**
 * Enum Type Definition
 *
 * Some leaf values of requests and input values are Enums. GraphQL serializes
 * Enum values as strings, however internally Enums can be represented by any
 * kind of type, often integers.
 *
 * Example:
 *
<<<<<<< HEAD
 * ```ts
 * const RGBType = new GraphQLEnumType({
 *   name: 'RGB',
 *   values: {
 *     RED: { value: 0 },
 *     GREEN: { value: 1 },
 *     BLUE: { value: 2 }
 *   }
 * });
 * ```
=======
 *     const RGBType = new GraphQLEnumType({
 *       name: 'RGB',
 *       values: {
 *         RED: { value: 0 },
 *         GREEN: { value: 1 },
 *         BLUE: { value: 2 }
 *       }
 *     });
>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
 *
 * Note: If a value is not provided in a definition, the name of the enum value
 * will be used as its internal value.
 */
<<<<<<< HEAD
export declare class GraphQLEnumType {
  name: string;
  description: Maybe<string>;
  extensions: Readonly<GraphQLEnumTypeExtensions>;
  astNode: Maybe<EnumTypeDefinitionNode>;
  extensionASTNodes: ReadonlyArray<EnumTypeExtensionNode>;
  private _values;
  private _valueLookup;
  private _nameLookup;
  constructor(config: Readonly<GraphQLEnumTypeConfig>);
  get [Symbol.toStringTag](): string;
  getValues(): ReadonlyArray<GraphQLEnumValue>;
  getValue(name: string): Maybe<GraphQLEnumValue>;
  serialize(outputValue: unknown): Maybe<string>;
  parseValue(inputValue: unknown): Maybe<any>;
  parseLiteral(
    valueNode: ValueNode,
    _variables: Maybe<ObjMap<unknown>>,
  ): Maybe<any>;
  toConfig(): GraphQLEnumTypeNormalizedConfig;
  toString(): string;
  toJSON(): string;
}
=======
export class GraphQLEnumType {
  name: string;
  description: Maybe<string>;
  extensions: Maybe<Readonly<GraphQLEnumTypeExtensions>>;
  astNode: Maybe<EnumTypeDefinitionNode>;
  extensionASTNodes: Maybe<ReadonlyArray<EnumTypeExtensionNode>>;

  constructor(config: Readonly<GraphQLEnumTypeConfig>);
  getValues(): Array<GraphQLEnumValue>;
  getValue(name: string): Maybe<GraphQLEnumValue>;
  serialize(value: any): Maybe<string>;
  parseValue(value: any): Maybe<any>;
  parseLiteral(
    valueNode: ValueNode,
    _variables: Maybe<{ [key: string]: any }>,
  ): Maybe<any>;

  toConfig(): GraphQLEnumTypeConfig & {
    extensions: Maybe<Readonly<GraphQLEnumTypeExtensions>>;
    extensionASTNodes: ReadonlyArray<EnumTypeExtensionNode>;
  };

  toString(): string;
  toJSON(): string;
  inspect(): string;
}

>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
export interface GraphQLEnumTypeConfig {
  name: string;
  description?: Maybe<string>;
  values: GraphQLEnumValueConfigMap;
  extensions?: Maybe<Readonly<GraphQLEnumTypeExtensions>>;
  astNode?: Maybe<EnumTypeDefinitionNode>;
  extensionASTNodes?: Maybe<ReadonlyArray<EnumTypeExtensionNode>>;
}
<<<<<<< HEAD
interface GraphQLEnumTypeNormalizedConfig extends GraphQLEnumTypeConfig {
  extensions: Readonly<GraphQLEnumTypeExtensions>;
  extensionASTNodes: ReadonlyArray<EnumTypeExtensionNode>;
}
export declare type GraphQLEnumValueConfigMap = ObjMap<GraphQLEnumValueConfig>;
=======

export interface GraphQLEnumValueConfigMap {
  [key: string]: GraphQLEnumValueConfig;
}

>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
/**
 * Custom extensions
 *
 * @remarks
 * Use a unique identifier name for your extension, for example the name of
 * your library or project. Do not use a shortened identifier as this increases
 * the risk of conflicts. We recommend you add at most one extension field,
 * an object which can contain all the values you need.
 */
export interface GraphQLEnumValueExtensions {
<<<<<<< HEAD
  [attributeName: string]: unknown;
}
=======
  [attributeName: string]: any;
}

>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
export interface GraphQLEnumValueConfig {
  description?: Maybe<string>;
  value?: any;
  deprecationReason?: Maybe<string>;
  extensions?: Maybe<Readonly<GraphQLEnumValueExtensions>>;
  astNode?: Maybe<EnumValueDefinitionNode>;
}
<<<<<<< HEAD
=======

>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
export interface GraphQLEnumValue {
  name: string;
  description: Maybe<string>;
  value: any;
  deprecationReason: Maybe<string>;
<<<<<<< HEAD
  extensions: Readonly<GraphQLEnumValueExtensions>;
  astNode: Maybe<EnumValueDefinitionNode>;
}
=======
  extensions: Maybe<Readonly<GraphQLEnumValueExtensions>>;
  astNode?: Maybe<EnumValueDefinitionNode>;

  // @deprecated and will be removed in v16
  isDeprecated: boolean;
}

>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
/**
 * Custom extensions
 *
 * @remarks
 * Use a unique identifier name for your extension, for example the name of
 * your library or project. Do not use a shortened identifier as this increases
 * the risk of conflicts. We recommend you add at most one extension field,
 * an object which can contain all the values you need.
 */
export interface GraphQLInputObjectTypeExtensions {
<<<<<<< HEAD
  [attributeName: string]: unknown;
}
=======
  [attributeName: string]: any;
}

>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
/**
 * Input Object Type Definition
 *
 * An input object defines a structured collection of fields which may be
 * supplied to a field argument.
 *
 * Using `NonNull` will ensure that a value must be provided by the query
 *
 * Example:
 *
<<<<<<< HEAD
 * ```ts
 * const GeoPoint = new GraphQLInputObjectType({
 *   name: 'GeoPoint',
 *   fields: {
 *     lat: { type: new GraphQLNonNull(GraphQLFloat) },
 *     lon: { type: new GraphQLNonNull(GraphQLFloat) },
 *     alt: { type: GraphQLFloat, defaultValue: 0 },
 *   }
 * });
 * ```
 */
export declare class GraphQLInputObjectType {
  name: string;
  description: Maybe<string>;
  extensions: Readonly<GraphQLInputObjectTypeExtensions>;
  astNode: Maybe<InputObjectTypeDefinitionNode>;
  extensionASTNodes: ReadonlyArray<InputObjectTypeExtensionNode>;
  private _fields;
  constructor(config: Readonly<GraphQLInputObjectTypeConfig>);
  get [Symbol.toStringTag](): string;
  getFields(): GraphQLInputFieldMap;
  toConfig(): GraphQLInputObjectTypeNormalizedConfig;
  toString(): string;
  toJSON(): string;
}
export interface GraphQLInputObjectTypeConfig {
  name: string;
  description?: Maybe<string>;
  fields: ThunkObjMap<GraphQLInputFieldConfig>;
=======
 *     const GeoPoint = new GraphQLInputObjectType({
 *       name: 'GeoPoint',
 *       fields: {
 *         lat: { type: new GraphQLNonNull(GraphQLFloat) },
 *         lon: { type: new GraphQLNonNull(GraphQLFloat) },
 *         alt: { type: GraphQLFloat, defaultValue: 0 },
 *       }
 *     });
 *
 */
export class GraphQLInputObjectType {
  name: string;
  description: Maybe<string>;
  extensions: Maybe<Readonly<GraphQLInputObjectTypeExtensions>>;
  astNode: Maybe<InputObjectTypeDefinitionNode>;
  extensionASTNodes: Maybe<ReadonlyArray<InputObjectTypeExtensionNode>>;

  constructor(config: Readonly<GraphQLInputObjectTypeConfig>);
  getFields(): GraphQLInputFieldMap;

  toConfig(): GraphQLInputObjectTypeConfig & {
    fields: GraphQLInputFieldConfigMap;
    extensions: Maybe<Readonly<GraphQLInputObjectTypeExtensions>>;
    extensionASTNodes: ReadonlyArray<InputObjectTypeExtensionNode>;
  };

  toString(): string;
  toJSON(): string;
  inspect(): string;
}

export interface GraphQLInputObjectTypeConfig {
  name: string;
  description?: Maybe<string>;
  fields: Thunk<GraphQLInputFieldConfigMap>;
>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
  extensions?: Maybe<Readonly<GraphQLInputObjectTypeExtensions>>;
  astNode?: Maybe<InputObjectTypeDefinitionNode>;
  extensionASTNodes?: Maybe<ReadonlyArray<InputObjectTypeExtensionNode>>;
}
<<<<<<< HEAD
interface GraphQLInputObjectTypeNormalizedConfig
  extends GraphQLInputObjectTypeConfig {
  fields: GraphQLInputFieldConfigMap;
  extensions: Readonly<GraphQLInputObjectTypeExtensions>;
  extensionASTNodes: ReadonlyArray<InputObjectTypeExtensionNode>;
}
=======

>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
/**
 * Custom extensions
 *
 * @remarks
 * Use a unique identifier name for your extension, for example the name of
 * your library or project. Do not use a shortened identifier as this increases
 * the risk of conflicts. We recommend you add at most one extension field,
 * an object which can contain all the values you need.
 */
export interface GraphQLInputFieldExtensions {
<<<<<<< HEAD
  [attributeName: string]: unknown;
}
export interface GraphQLInputFieldConfig {
  description?: Maybe<string>;
  type: GraphQLInputType;
  defaultValue?: unknown;
=======
  [attributeName: string]: any;
}

export interface GraphQLInputFieldConfig {
  description?: Maybe<string>;
  type: GraphQLInputType;
  defaultValue?: any;
>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
  deprecationReason?: Maybe<string>;
  extensions?: Maybe<Readonly<GraphQLInputFieldExtensions>>;
  astNode?: Maybe<InputValueDefinitionNode>;
}
<<<<<<< HEAD
export declare type GraphQLInputFieldConfigMap =
  ObjMap<GraphQLInputFieldConfig>;
export interface GraphQLInputField {
  name: string;
  description: Maybe<string>;
  type: GraphQLInputType;
  defaultValue: unknown;
  deprecationReason: Maybe<string>;
  extensions: Readonly<GraphQLInputFieldExtensions>;
  astNode: Maybe<InputValueDefinitionNode>;
}
export declare function isRequiredInputField(field: GraphQLInputField): boolean;
export declare type GraphQLInputFieldMap = ObjMap<GraphQLInputField>;
export {};
=======

export interface GraphQLInputFieldConfigMap {
  [key: string]: GraphQLInputFieldConfig;
}

export interface GraphQLInputField {
  name: string;
  description?: Maybe<string>;
  type: GraphQLInputType;
  defaultValue?: any;
  deprecationReason: Maybe<string>;
  extensions: Maybe<Readonly<GraphQLInputFieldExtensions>>;
  astNode?: Maybe<InputValueDefinitionNode>;
}

export function isRequiredInputField(field: GraphQLInputField): boolean;

export interface GraphQLInputFieldMap {
  [key: string]: GraphQLInputField;
}
>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
