<<<<<<< HEAD
import { isPromise } from './isPromise.mjs';

=======
import isPromise from "./isPromise.mjs";
>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
/**
 * Similar to Array.prototype.reduce(), however the reducing callback may return
 * a Promise, in which case reduction will continue after each promise resolves.
 *
 * If the callback does not return a Promise, then this function will also not
 * return a Promise.
 */
<<<<<<< HEAD
export function promiseReduce(values, callbackFn, initialValue) {
  let accumulator = initialValue;

  for (const value of values) {
    accumulator = isPromise(accumulator)
      ? accumulator.then((resolved) => callbackFn(resolved, value))
      : callbackFn(accumulator, value);
  }

  return accumulator;
=======

export default function promiseReduce(values, callback, initialValue) {
  return values.reduce(function (previous, value) {
    return isPromise(previous) ? previous.then(function (resolved) {
      return callback(resolved, value);
    }) : callback(previous, value);
  }, initialValue);
>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
}
