<<<<<<< HEAD
import type { GraphQLCompositeType, GraphQLType } from '../type/definition';
import type { GraphQLSchema } from '../type/schema';
/**
 * Provided two types, return true if the types are equal (invariant).
 */
export declare function isEqualType(
  typeA: GraphQLType,
  typeB: GraphQLType,
): boolean;
=======
import { GraphQLSchema } from '../type/schema';
import { GraphQLType, GraphQLCompositeType } from '../type/definition';

/**
 * Provided two types, return true if the types are equal (invariant).
 */
export function isEqualType(typeA: GraphQLType, typeB: GraphQLType): boolean;

>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
/**
 * Provided a type and a super type, return true if the first type is either
 * equal or a subset of the second super type (covariant).
 */
<<<<<<< HEAD
export declare function isTypeSubTypeOf(
=======
export function isTypeSubTypeOf(
>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
  schema: GraphQLSchema,
  maybeSubType: GraphQLType,
  superType: GraphQLType,
): boolean;
<<<<<<< HEAD
=======

>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
/**
 * Provided two composite types, determine if they "overlap". Two composite
 * types overlap when the Sets of possible concrete types for each intersect.
 *
 * This is often used to determine if a fragment of a given type could possibly
 * be visited in a context of another type.
 *
 * This function is commutative.
 */
<<<<<<< HEAD
export declare function doTypesOverlap(
=======
export function doTypesOverlap(
>>>>>>> efb60b5ba318ea79afa9b17c06eb55420dda5343
  schema: GraphQLSchema,
  typeA: GraphQLCompositeType,
  typeB: GraphQLCompositeType,
): boolean;
